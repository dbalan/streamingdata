# API Spec
1. All access is through gRPC 
2. Values ones read from the server is assumed to be recieved by client, and should not be lost (this is true for network because tcp ensures the ordered delivery of packets), but if the client looses the data due to anything above network, this api would fail.
3. Server can process as many simultaneous requests as resources allow, we would definitely have a problem if we exhaust the port space, number of fd set by ulimit (should be disabled in linux), storage space provided by the storage backend used and network badwidth available.
4. Server is responsible for sending the data in intervals and closing the connection when specified number of data has been sent.


## API Specs
### GetStateLessStream
Defined as `rpc GetStateLessStream (StateLessRequest) returns (stream IntResponse) {}`

This API returns a bound stream of numbers each subsequent number being twice of the previous one.

#### Input
This api takes `StateLessRequest` as an input and returns a stream of numbers.

```
message StateLessRequest {
  int64 count = 1;
  uint32 lastseen = 2; // optional value, used for reconnecting
}
```
- count: number of values the client needs from the stream, this is the length of the stream, after sending count number of numbers, server closes the connection. If the client is trying to reconnect, this should be set as the number of remaining values.

- lastseen: optional, only set for reconnects. This is the last seen value by client before connection was terminated.

#### Output
API returns a `IntResponse` stream as response.

```
message IntResponse {
  uint32 current_val = 1;
}
```
- current_val is the current response from server.

#### Reconnect
Client is responsible for keeping track of state while re-connecting, lastseen param should be set properly what reconnecting. Also, it would be nice to have an exponential backoff mechanism while retrying.

#### Server states
None

#### Client States
1. Data recieved so far, and last_seen element and remaining number of elements

### GetStateFullStream
Defined as `rpc GetStateFullStream (StateFullRequest) returns (stream StateFullResponse) {}`

This API returns a bound stream of random number sequences from a deterministic RNG. In case of disconnections the clients have 30s to reconnect otherwise the state is forgotten.

RNG is seeded with a random number at the first request by client, a.k.a when the server encounters a new clientID. The seed is stored in the state and RNG is re-seeded when there is a reconnect.

#### Input
- clientID: string, this identifies the client connection, randomly generated by the client
- count: the length of stream (number of rnd outputs client needs), int64

#### Output
- error: if the client is trying to reconnect and 30 seconds have passed, server would respond with keyexpired error.

A succesfull call responds with a stream of `StateFullResponse`

```
message StateFullResponse {
  uint32 current_val = 1;
  string hash_sum = 2; // will only be set for last message.
}
```

- current_val, current rng output
- hash_sum: sha256 hash of all the numbers that were sent, optional, only set for last message.

#### Reconnect
Server is responsible for keeping track of reconnections as long as 30s has not expired after last disconnect. Client need not do anything other than retrying with the same clientID, and keeping track of data already recieved.

#### Server state
Server stores 
1. the client ID: to identify the client connection, if it gets disconnected.
2. number of elements sent - this removes the same state need to be stored in client.
3. the seed for the PRNG being used - this could be replaced with a PRNG state.
4. last disconnect time for expiring keys
We could maybe remove the seed and store the PRNG state ifself which would save a bit of computation for the server, but however that means we would have to save the hash states too.

